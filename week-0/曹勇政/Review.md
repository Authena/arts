## 译《TDD改变了我的生活》

现在是早上7.05分，对用户的支持陷入了困境。我们刚在《早安美国》上亮相，报道有大量的新用户遇到的bug。

每个人都在全力以赴。我们需要立即发布热修复程序，以免丢失更多的新用户。其中一位开发人员做了更改并认为可以解决问题。
我们将暂存更改链接粘贴到公司聊天室中，并要求所有人在将修补程序投入生产之前进行测试。更改成功了！

我们的运维启动了他的部署脚本，几分钟后，更改就生效了。突然，客户报障电话量增加了一倍。因为我们的热修补程序破坏了其他东西，在开发人员在找原因的同时运维撤销了这次更改。

#### 为什么选择测试去掉开发？

已经有有一段时间没有再遇到这种情况了。不是因为开发不再犯错误，而是因为几年来，我领导和工作的团队都在执行TDD政策。当然bug仍会产生，但即使软件更改和升级维护负担的速度成倍增加，推送到生产环境中的令人难以置信的错误的已降至接近零。

每当有人问我为什么要他们要使用TDD时，我都会想起这个故事-还有数十个类似的故事。我使用测试驱动的主要原因之一是为了提高测试范围，这能使生产中的错误减少40％-80％。这是我最喜欢的测试驱动的原因。就像巨大的力量举起了你的肩膀。

测试驱动消除了开发对更改代码的恐惧。

在我的项目中，我们的自动化单元和功能测试套件防止灾难性的重大变更几乎每天都发生。举例来说，我目前正在查看过去一周对图书馆进行的10项自动化库升级，我过去一直对合并抱有偏执，因为如果合并会破坏某些内容怎么办？我目前正在查看过去一周内进行的10项自动化库升级，这些升级曾经使我对合并抱有偏执，因为如果它发生了故障，该怎么办？

所有这些升级都自动集成，并且已经投入生产，我没有手动查看它们中的任何一个，也不用担心它们。我不必去特别去寻找例子。我打开GitHub，查看了最近的合并，然后就找到了。从前的手动维护（或更糟糕的是，被忽视）现在变成了自动化的后台过程。您可以在没有良好的测试覆盖率的情况下尝试此操作，但我不建议您这样做。

#### 什么是TDD？

TDD代表测试驱动开发。过程很简单：
![](https://miro.medium.com/max/2400/1*-Qk4PaEr5CR6EQ3vhvRWyg.png)

1. 在编写实现代码之前，请编写一些代码来证明实现有效或失败。在继续下一步之前，请先观察测试失败（这是我们知道通过测试不是误报的一种方式-我们如何测试测试）。
2. 编写实现代码并观看测试通过。
3. 必要时进行重构。现在，您可以通过测试来告诉您是否已破坏某些内容，从而可以自信地重构代码。

#### TDD如何节省您的开发时间

从表面上看，编写所有这些测试似乎是很多额外的代码，而所有这些额外的代码都需要花费额外的时间。起初，这对我来说是对的，因为我一开始就很难理解如何编写可测试的代码，并且很难理解如何向已编写的代码中添加测试。

TDD有一个学习曲线，当您攀登该学习曲线时，它可以而且经常确实增加15％到35％的实施时间。但是在大约2年的某个地方，神奇的事情开始发生：与没有单元测试相比，我开始使用单元测试的编码速度更快。

几年前，我在UI中构建了视频剪辑范围功能。想法是，您要为视频设置起点和终点，并且当用户链接到该视频时，它将链接到该精确剪辑，而不是整个视频。

但这没用。玩家将到达剪辑的结尾并继续播放，我不知道为什么。

我一直认为这与事件侦听器无法正确连接有关。我的代码如下所示：

```js
video.addEventListener('timeupdate', () => {
  if (video.currentTime >= clip.stopTime) {
    video.pause();
  }
});
```

更改。编译。重新加载。单击。等待。重复。

每次更改都花了将近一分钟的时间来测试，我尝试了很多有趣的事情（大多数情况下是2-3次）。

我拼错了`timeupdate`吗？我的API正确吗？ `video.pause()`调用正常吗？我要进行更改，添加`console.log()`，跳回浏览器，单击刷新，单击剪辑结束之前的一刻，然后耐心等待它结束。`if`语句里面的打印什么都没有做。好吧，这是一个线索。从api文档复制粘贴的`timeupdate`绝对不是一个错字。刷新，点击，等待。幸运并不存在！

最后，我把`console.log()`放在了`if`语句外面。“这并没有什么帮助”，我想。毕竟，那个`if`语句如此简单，我不可能弄乱逻辑。它打印了。我把咖啡吐在键盘上。 WTF ？！

>墨菲的调试定律：您无需费心测试因为您深信不可能出错的地方，肯定是在您将头撞到桌子上并进行更改之后才能发现错误在这个地方，因为您已经尝试了所有其他可以想到的东西的。

我设置了一个断点以弄清楚到底发生了什么。我检查了`clip.stopTime`的值。`undefined`???我回头检查我的代码。用户单击以选择停止时间时，它点击了小停止光标图标，但从来没有设置`clip.stopTime`。“天哪，我是个大笨蛋，只要我活着，任何人都不能再让我在计算机附近的任何地方。”

多年以后，由于那种感觉，我仍然记得这一点。您完全知道我在说什么。我们都去过那里。我们都是活着的模因。

![](https://miro.medium.com/max/2048/1*9ZbCv6O3Sr7x6d3lt3uNRA.png)

如果我今天正在编写该UI，那么我将从以下内容开始：

```js
describe('clipReducer/setClipStopTime', async assert => {
  const stopTime = 5;
  const clipState = {
    startTime: 2,
    stopTime: Infinity
  };
  assert({
    given: 'clip stop time',
    should: 'set clip stop time in state',
    actual: clipReducer(clipState, setClipStopTime(stopTime)),
    expected: { ...clipState, stopTime }
  });
});
```

从表面上看，这看起来比`clip.stopTime = video.currentTime`代码要多得多。但这就是重点。此代码的行为类似于规范。文档，以及证明代码按文档记载工作的证明。并且因为它存在，所以如果我更改方式，将停止时间光标定位在x，y轴上，我不必担心在此过程中是否会破坏剪辑停止时间代码。

>注意：是否要编写这样的单元测试？请查看“[重新考虑单元测试断言](https://medium.com/javascript-scene/rethinking-unit-test-assertions-55f59358253f)”。

关键不是键入此代码要花费多长时间。关键是如果出现问题，调试需要多长时间。如果此代码损坏，则此测试将为我提供一个不错的错误报告。我马上知道问题不是事件处理程序。我知道它在`setClipStopTime()`或`clipReducer()`中,它们实现状态突变。我会知道它应该做什么，实际输出和预期输出-更重要的是-未来六个月的同事也会尝试向我构建的代码添加功能。

我在每个项目中要做的第一件事就是设置一个监视脚本，该脚本在每次文件更改时自动运行我的单元测试。我经常与两个监视器并排编写代码，并使我的开发控制台在一个监视器上运行监视脚本，而在另一个监视器上运行。当我进行更改时，我通常会在3秒钟内知道该更改是否有效。

对我来说，TDD不仅仅是安全网。它还是持续，快速，实时的反馈。当我做对的时候立即得到满足。当我发现错误时，立即提供描述性错误报告。

#### TDD教我如何编写更好的代码

我要承认一个令人尴尬的事情：在通过单元测试学习TDD之前，我不知道如何构建应用程序。我受雇的方式超出了我的范围，但是在采访了数百名开发人员之后，我可以很有信心地告诉你：很多数开发者都和我一样。TDD教会了我几乎所有有关软件组件（包括模块，功能，对象，UI组件等）的有效去耦和组成的知识。

这样做的原因是因为单元测试迫使您测试的组件彼此之间以及与I / O的隔离。给定一些输入，被测单元应产生一些已知的输出。如果不是，则测试失败。如果是，则通过。关键是它应该独立于应用程序的其余部分来执行此操作。如果您要测试状态逻辑，则应该能够测试它，而无需在屏幕上呈现任何内容或将任何内容保存到数据库。如果您要测试UI渲染，则应该能够测试它，而无需在浏览器中加载页面或访问网络。

除其他事项外，TDD告诉我，当您将UI组件保持在最小限度时，生活会变得简单得多。从UI隔离业务逻辑和副作用。实际上，这意味着如果您使用的是基于组件的UI框架，例如React或Angular，创建显示组件和容器组件并使它们分开可能是有利的。

对于显示组件，传入确定的属性，它们总是渲染相同的状态。这些组件可以轻松进行单元测试，以确保传入的属性正确控制组件，且UI布局中的任何条件逻辑都可以正常工作（例如，如果列表为空，则列表组件根本不应该呈现，它应该发出请求以将一些内容添加到列表中）。

我在学习TDD之前就已经知道要分离重点，但是我不知道如何分离重点。

单元测试教会了我使用模拟来测试事物的知识，然后教会我[模拟是一种代码味道](https://medium.com/javascript-scene/mocking-is-a-code-smell-944a70c90a6a)，这让我大吃一惊，彻底改变了我编写软件的方式。

[所有软件开发均由以下部分组成](https://leanpub.com/composingsoftware)：将大问题分解为许多小的，易于解决的问题的过程,然后针对这些问题编写解决方案以形成应用程序。为进行单元测试而进行的模拟表明您组成的原子单位不是真正的原子，学习如何在不牺牲测试覆盖率的情况下消除模拟，教会了我如何发现大量紧密耦合的隐秘来源。

这使我成为一名更好的开发人员，并教会我如何编写更简单的代码，这些代码更易于扩展，维护和扩展，包括既复杂又跨大型分布式系统（如云基础架构）。

#### TDD如何节省整个团队的时间

我之前提到过，[测试首先可以提高测试覆盖率](https://ieeexplore.ieee.org/abstract/document/4343755)。
原因是在编写测​​试以确保其有效之前，我们不会开始编写实现代码。**首先，编写测试**。然后看着它失败。然后编写实现代码。失败，通过，重构，重复。

这个过程建立了一个安全网，几乎不会有任何漏洞通过，并且该安全网对整个团队产生了不可思议的影响。**它消除了对合并按钮的恐惧。**

令人放心的覆盖范围数字使您的整个团队有信心停止对代码库的每一个微小更改进行管理，并**使更改蓬勃发展。**

消除对变更的恐惧就像为机器上油。如果您不这样做，则机器会停止运转，直到您清理干净并摇动它，然后吱吱作响，然后重新磨动。

没有这种恐惧，开发节奏就可以流畅得多。拉取请求停止备份。CI / CD正在运行测试-如果测试失败，它将停止。它将大声失败，并指出发生错误的地方。

一切都与众不同。

#### 想更多地了解TDD？

TDD Day是2019年6月14日星期五录制的全天实时网络研讨会。您仍然可以注册以观看录制的视频。

您将学到：

* 为什么TDD接管开发
* 软件质量经济学
* 单元，功能，集成测试
* 每个单元测试必须回答的5个问题
* TDD RITE方式
* 模拟是一种代码气味
* 为什么可测试的软件可以带来更好的架构
* 紧密耦合的原因
* 如何使用纯函数做更多事情
* 单元测试React组件

[现在注册。](https://zoom.us/webinar/register/WN_rYdjYdXFTPiHCsiWsnq0jA)

埃里克·埃利奥特（Eric Elliott）是这些书的作者，[“编写软件”](https://leanpub.com/composingsoftware)和[“编写JavaScript应用程序”。](http://pjabook.com/)作为[EricElliottJS.com](https://ericelliottjs.com/)和[DevAnywhere.io](https://devanywhere.io/)的共同创始人，他教开发人员基本的软件开发技能。他建立并为加密项目的开发团队提供建议，并为**Adobe系统，Zumba Fitness，《华尔街日报》，ESPN，BBC，**以及顶尖的唱片艺术家，包括**Usher，Frank Ocean，Metallica**等。

他与世界上最美丽的女人一起过着偏僻的生活方式。

ps: [原文链接](https://medium.com/javascript-scene/tdd-changed-my-life-5af0ce099f80)