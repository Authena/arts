对象在 Javascript 中应用得很普遍，理解如何有效地使用他们会给你的产出带来很大帮助。事实上，糟糕的 OO 设计会潜在性的导致项目的失败，甚至公司的失败。
与大多数其他语言不同的是，JavaScript 的对象系统是基于**原型的，而非类**。不幸的是，大多数 Javascript 开发者并不理解 Javascript 的对象系统和如何去更好的使用他。一些人的确理解它，但想让它表现得更像基于类的系统。Javascript 开发者需要了解原型和类，因为 Javascript 对象系统具有令人困惑的分离的特性。

## 类和原型继承有什么区别？

这可能会是一个棘手的问题，你也许需要后续的问答来寻找答案，因此请特别注意去学习他们的区别和如何应用它来写更好的代码。

**类继承： 一个类就像是一个蓝图——一个对象被创建后的描述**。类继承其他类并且**创建子类关系**：等级制的类的分类法。

实例通常被带有“new”关键字的构造函数来实例化。类继承也许会使用 ES6 的“class”关键字。Java 中存在的类与 Javascript 的并不相同，不同的是，Javascript 使用构造函数。用 ES6 的“class”关键字来构造函数
`class Foo {} typeof Foo // 'function'`
在 Javascript 中，类继承是在原型继承之上实现的，但是这并不意味着两者相同。

Javascript 类继承通过原型链将子代“Constructor.prototype”与父代的“Constructor.prototype”相连来委派。通常，还会调用"super()"构造函数。这些步骤形成了**单祖先父/子层级结构**同时**建立了在 OO 设计中可用的最紧密的耦合关系**。

类继承其他类并且创建子类关系：等级制的类的分类法。

**原型继承：一个原型是一个工作的对象实例**。对象直接从其他对象继承。

实例可以由许多不同的源对象组成，允许容易的选择性继承和扁平的[[Prototype]]委托层级结构。换句话说，**类分类法不是原型 OO 的自动副作用**：这是一个关键的区别

实例化通常通过工厂函数，Object，或者"Object.create()"

原型是一个工作对象实例. 对象直接从其他对象继承。

## 为什么这很重要？

继承基本上是一种代码重用机制：一种让不同类型的对象共享代码的方法。你共享代码的方式很重要，因为如果你弄错了，**它会产生很多问题**，具体来说

**类继承创建父/子对象分类法作为一个副作用**

那些分类法几乎不可能适用于所有新的用例，并且基类的广泛使用导致了**脆弱的基类问题**，这使得当你弄错它们时很难修复它们。事实上，类继承在 OO 设计中引起许多众所周知的问题：

* 紧耦合问题 （类继承是 oo 设计中可用的最紧密耦合），这导致下一个......

* 脆弱的基类问题

* 不灵活的层级结构问题（最终，所有不断发展的层级结构对于新用途都是错误的

* 重复的必要性问题(由于不灵活的层次结构，新的用例通常是通过复制而不是调整现有代码来实现的)

* 大猩猩/香蕉问题（你想要一个香蕉，但得到的却是一个大猩猩拿着香蕉，而且还有整个丛林。)-- 面向对象总是附带着所有它需要的隐含环境。

我在演讲中更深入地讨论了一些问题，“经典继承已经过时：如何在 Prototypal OO 中思考”

所有这些问题的解决方案是支持对象组合而不是类继承

支持对象组合而不是类继承。”“设计模式：可重用面向对象软件的元素”

## 所有继承都不好吗？

当人们说“支持组成而不是继承”，这是“支持组合超过**类**继承”的缩写。这是 OO 设计中的常识，因为类继承有**许多缺陷**并导致许多问题。人们常常在谈论类继承时忽略**类**字，这听起来像所有的继承都很糟糕 - 但事实并非如此。

实际上有几种不同的继承，其中大多数都非常适合从多个组件对象组合复合对象

## 三种不同的原型继承

在我们深入研究其他类型的继承之前，让我们仔细看看我认为的**类继承**

[codepen](http://codepen.io/ericelliott/pen/pgdPOb?editors=001)

BassAmp继承自GuitarAmp，而'ChannelStrip继承自'BassAmp和GuitarAmp。这是OO设计出错的一个例子。一个channel strip实际上不是一种GuitarAmp，而且根本不需要cabinet。一个更好的选择是创建一个ChannelStrip和Amp继承的新基类，但即便如此也有局限性。

最终，这个新的共享基类的策略也会崩溃。

这有一个更好的方法，你可以通过对象组合的方法来继承你刚好且真正需要的东西。

[codepen](http://codepen.io/ericelliott/pen/XXzadQ?editors=001)

如果你仔细观察的话，你可能会发现我们更加明确哪些对象获得哪些属性，因为有了合成。它不是真正的类继承选项。当你继承一个类时，你得到了所有东西，尽管你不想这样。

在这里，你也许会自己思考，“那很棒，不过原型在哪？”

要理解这一点，你必须理解有三种方式的原型OO设计。

**连续继承**：通过复制源对象属性将要素直接从一个对象继承到另一个对象的过程。在JavaScript中，源原型通常被称为 mixins。从ES6开始，这个特性在JavaScript中有一个名为Object.assign（）的便利工具。在ES6之前，这通常使用Underscore / Lodash的.extend（）jQuery的$ .extend（）等等......上面的组合示例使用了连接继承。

**原型委托**：在JavaScript中，对象可能具有委托原型的链接。如果在对象上找不到属性，那么这个查找会被委托给委托原型，这个委托原型可能有一个链接到它自己的委托原型，依此类推，直到你到达Object.prototype，这是根委托。当你连接Constructor.prototype并用new实例化时，这是连接起来的原型。您也可以使用Object.create（）来实现此目的，甚至将此技术与串联混合，以便将多个原型展平为单个委托，或者在创建后扩展对象实例。

**函数继承**：在JavaScript中，任何函数都可以创建一个对象。当该函数不是构造函数（或class）时，它被称为工厂函数。功能继承的工作原理是从工厂生成对象，并通过直接为其分配属性来扩展生成的对象（使用连接继承）。Douglas Crockford创造了这个术语，但功能继承在JavaScript中已经普遍使用了很长时间。

正如您可能开始意识到的那样，**连接继承是在JavaScript中实现对象组合的秘诀**，这使得原型委派和函数继承更加有趣。

当大多数人想到JavaScript中的原型OO时，他们会想到原型委托。到现在你应该看到他们错过了很多东西。委托原型不是类继承的绝佳替代 - **对象组合**是。

## 为什么组合对脆弱的基类问题免疫

要理解脆弱的基类问题及其不适用于组合的原因，首先您必须了解它是如何发生的：
    
1. A是基类
2. B继承自A
3. C继承自B
4. D继承自B

C调用super，它在B中运行代码。B调用super，它在A中运行代码。

A和B包含C和D所需的不相关联的特征。D是一个新的用例，和C的需求相比需要在A的初始代码中表现出一点点不同。所以新手开发人员去调整A的初始化代码。C中断因为它依赖于现有的行为，然后D开始工作。

我们这里有的是在A和B之间散布的特征，他们是C和D需要以各种方式使用的。C和D不使用A和B的每一个特征......他们只想继承一些已经在A和B中已经定义的东西。但是通过继承和调用super方法，**你不会选择你继承的东西**。你继承了一切：

......面向对象语言的问题在于，他们已经拥有了他们身上东西的所有隐含的环境。你想要一个香蕉，但得到的却是一个大猩猩拿着香蕉，而且还有整个丛林。~Joe Armstrong

## 通过组合

想象一下，你有特征而不是类：
<code>feat1, feat2, feat3, feat4</code>
C需要feat1和feat3，D需要feat1，feat2，feat4：
<code>const C = compose(feat1, feat3);const D = compose(feat1, feat2, feat4);</code>
现在，想象一下你发现D需要与feat1略有不同的行为。它实际上并不需要改变feat1，相反，你可以制作feat1的定制版本并使用它。你仍然可以继承feat2和feat4中的现有行为而不做任何更改：
<code>const D = compose(custom1, feat2, feat4);</code>

而且**C仍然不受影响**。

这种情况在类继承不可能的原因是因为**当你使用类继承时，你会购买整个现有的类分类**。

如果您想稍微适应一个新的用例，您要么最终复制现有分类法的部分（必要性重复问题），要么依赖于现有分类法的所有内容来重构以使分类法适应新的用例导致**脆弱的基类问题**。

组合方法对两者都免疫。

## 你认为你知道原型，但......

如果你被教导构建类或构造函数并继承那些，你所教的是不是**原型继承**。你被教导如何**使用原型模仿类继承**。请参阅[关于JavaScript中继承的常见误解](https://medium.com/javascript-scene/common-misconceptions-about-inheritance-in-javascript-d5d9bab29b0a)。

在JavaScript中,很久以前内置于语言中的非常丰富，灵活的原型继承功能把类继承背在背上，但是当你使用类继承 - 甚至是在原型之上构建的ES6+class继承时，你不是在使用原型OO的全部功能和灵活性。事实上，你正在把自己画进角落里，并且选择了所有的类继承问题。

[原文](https://medium.com/javascript-scene/master-the-javascript-interview-what-s-the-difference-between-class-prototypal-inheritance-e4cd0a7562e9#.h96dymht1)